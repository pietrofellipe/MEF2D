load "gmsh"
        verbosity = 0;
        //mesh Th = gmshload("W:/TrabalhoMEF2D/MalhasGMSH/Malhasparaloop/Nucleo_E_I - integral.msh");
        mesh Th = gmshload("C:/Users/Pietro/Documents/GitHub/MEF2D/Mesh/Malhasparaloop/Nucleo_E_I - integral.msh");
        plot (Th, wait = 1, cmm = "Malha");

        // Definição das regions dentro do arquivo .geo
        // ar = 1
        // entreferro = 2
        // culatra inferior = 3
        // nucleo superior = 4
        // coil = 5
        // nucleo superior 2 = 6
        // nucleo superior 3 = 7
        // simetria = 101

        
        fespace ThP0(Th, P0);
        fespace ThP1(Th, P1);

        ThP0 Bx, By, normb; // variáveis Bx By e norma de B
        ThP0 mu;
            
        ThP0 reg = region;
        plot (reg, wait = 1, fill = 1, cmm = "Espacos P0");

        real mu0 = 4*pi*1e-7;

        // lei constitutiva não linear
        func real muNL(real B){
                real a = 100;   // m/H
                real b = 10;    // m/H
                real c = 1.8;   // T^-2
                return 1.0/(a + b * exp(c*B*B)); // μ(B)
        }
     
        ThP0 regnonlin = (reg==3) + (reg==4) + (reg==6) + (reg==7); 
        // inicializa mu com valor linear
        mu = mu0*(reg==1) + mu0*(reg==2) + 1000*mu0*regnonlin + mu0*(reg==5);

        
        real area = int2d(Th, 5)(1);
        //cout << "Area do coil = " << area << endl;
        plot (mu, wait = 1, fill = 1, cmm = "regioes mu de 1000*u0 e de u0");

       
        real iindividual = 5;
        real espiras = 1000;
        real j=(espiras * iindividual)/area; // (A/m^2) N=1000 e i=32A espira ampere-espira = 32 000 S = 0.01m^2
        ThP1 a, w, da;

        int nmaxit = 100;
        for (int k=0; k<nmaxit; k++){

          solve magstat(a,w) = int2d(Th)((1./mu) * (dx(a)*dx(w) + dy(a)*dy(w)))   
                          -   int2d(Th, 5)(j*w)  
                          +   on (102, a = 0)
                          +   on (101, a = 0);

          //plot (a, wait = 1, fill = true, value = 1, cmm = "rot a");
          // calcula B 
          Bx=dy(a);
          By=-dx(a);
          normb = sqrt(Bx^2+By^2);

          real alpha = 0.1; // fator de relaxação
            for (int i=0; i<mu[].n; i++){
                if(regnonlin[][i]==1){
                    real munew = muNL(normb[][i]);
                    mu[][i] = (1 - alpha)*mu[][i] + alpha*munew;
                }
            }
        plot(normb, wait=1, fill=1, value=1, cmm="|B| iteracao "+k);
        cout << "Iteracao " << k << " concluida" << endl;
        cout << "Valor mu core" << mu(0.05, 0.05) << endl;
}

                        
                real energiatotal = int2d(Th)((Bx^2 + By^2)/(2*mu));
                //real energiasqrt = int2d(Th)(normb^2)/(2*mu0);
                real indutanciaenergia = energiatotal*2/(iindividual)^2;
                real indutanciafluxo = (espiras * int1d(Th, 400)(-By)) / iindividual;
                //real fluxomedio = (1/(espiras * iindividual)) * int2d(Th, 5)(a*j);
                //real indutanciafluxomedio = (espiras * fluxomedio) / iindividual;

                cout << "Valor de B no entreferro interno" << normb(0.05,-0.01) << endl;
                cout << "Valor de B no entreferro externo" << normb(0.25,-0.01) << endl;
                cout << "Valor da energia " << energiatotal << endl;
                //cout << "Valor da indutancia por energia " << indutanciaenergia << endl;
                //cout << "Valor da indutancia por fluxo no entreferro " << indutanciafluxo << endl;
                //cout << "Valor da indutancia por fluxo medio " << indutanciafluxomedio << endl;


                plot ([Bx, By], wait = 1, value = 1, cmm = "Bx By");


                //real integralAJ = int2d(Th, 5)( a * j );   // ∫_coil A J dS

                //cout << "integral AJ = " << integralAJ << endl;

                //cout << "2*energiaTotal = " << 2*energiatotal << endl;

